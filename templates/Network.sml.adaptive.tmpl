
structure {{group.name}} =
struct

  structure D = Dynamics

  structure SEventPriority = 
  struct
       type priority     = real

       fun compare (x,y) = Real.compare (x,y)
       type item         = real * int
       fun priority (x : item) = (#1(x))
  end
      
  structure SEQ = TEventQueue (structure P = SEventPriority
                               type value = int
                               fun value (x : P.item) = (#2(x)))

  fun putStrLn out str = 
      (TextIO.output (out, str);
       TextIO.output (out, "\n"))
    
  fun putStr out str = 
      (TextIO.output (out, str))
      
  fun showBoolean b = (if b then "1" else "0")
                      
  fun showReal n = 
      let open StringCvt
	  open Real
      in
	  (if n < 0.0 then "-" else "") ^ (fmt (FIX (SOME 12)) (abs n))
      end

  fun showRealArray v = 
      (String.concatWith ", " (Array.foldr (fn (x, ax) => (showReal x)::ax) [] v))
      
  fun foldl1 f lst = let val v = List.hd lst
                         val lst' = List.tl lst
                     in
                         List.foldl f v lst'
                     end

  fun dimVals [m,n] = (m,n) | dimVals _ = raise BitSparseMatrix.Shape

  fun fromDiag (m, n, a, dflt) =
      if Index.validShape [m,n]
      then 
          (let 
               val na  = BitTensor.Array.length a
               val na' = na-1
               val te  = BitTensor.new ([m,n], dflt)
               fun diag (i, j, ia) =
                   let
                       val ia' = 
                           (BitTensor.update (te, [i,j], BitTensor.Array.sub (a, ia));
                            if ia = na' then 0 else ia+1)
                   in
                       if (i=0) orelse (j=0) 
                       then te
                       else diag (i-1, j-1, ia)
                   end
           in
               diag (m-1, n-1, 0)
           end)
      else 
          raise Index.Shape


  fun sampleN randomInt n dflt =
      let
          val i = ref 0
          val sample = Array.array (n+1, dflt)
          val update = Unsafe.Array.update
      in
          (sample,
           fn (x) =>
              (i := (!i)+1;
               if (!i) <= n
               then update (sample, !i, x)
               else (let val k = randomInt (0, !i) 
                     in 
                         if k < n then update(sample, randomInt (0, n), x) else ()
                     end)))
      end

  fun assoc ((k,v)::rst) x = if k=x then SOME v else assoc rst x
    | assoc [] x = NONE 

  fun member (k,lst) = case List.find (fn(x)=>k=x) lst of SOME _ => true | NONE => false

  fun index_foldri (a, b, f, init) =
      if a <= b then
          index_foldri (a, b-1, f, f (b, init))
      else
          init

  val getindex = Unsafe.Array.sub


  val RandomInitFromInt = RandomMTZig.fromInt
  val RandomInit = RandomMTZig.fromEntropy

  val ZigInit = RandomMTZig.ztnew

  fun optApply fopt args =
      case fopt of SOME f => SOME (f args) | NONE => NONE

  fun make_initial_vector (alloc,bool_alloc,n,nev,ndsc,nregime) 
                          (i,condfun,initial,SOME evinitial,dinitial,SOME rinitial,extinitial,extevinitial,h0) =
      let 
          val dinitial': real array -> real array = 
              case dinitial of
                  SOME v => v
                | NONE => (fn v => v)
      in
          D.condApply condfun (D.RegimeState (0.0, 0.0, initial(alloc n), 0.0, evinitial (alloc nev), dinitial' (alloc ndsc), 
                                              rinitial (bool_alloc nregime), extinitial(), extevinitial(), h0, 
                                              alloc n, alloc n, alloc n, alloc nev, false))
      end
   |  make_initial_vector (alloc,bool_alloc,n,nev,ndsc,nregime) 
                          (i,condfun,initial,SOME evinitial,NONE,NONE,extinitial,extevinitial,h0) =
      D.condApply condfun (D.EventState (0.0, 0.0, initial(alloc n), 0.0, evinitial (alloc nev), 
                                         extinitial (), extevinitial (), h0, 
                                         initial(alloc n), initial(alloc n), alloc n,
                                         alloc nev, false))
   |  make_initial_vector (alloc,bool_alloc,n,nev,ndsc,nregime) 
                          (i,condfun,initial,NONE,NONE,NONE,extinitial,extevinitial,h0) =
      D.ContState (0.0, 0.0, initial(alloc n), extinitial(), extevinitial(), h0, alloc n, alloc n, alloc n)
   |  make_initial_vector (alloc,bool_alloc,n,nev,ndsc,nregime) 
                          (i,condfun,initial,_,_,_,extinitial,extevinitial,h0) =
      (putStrLn TextIO.stdOut "make_initial_vector:"; raise Domain)

  fun update_h (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, _, ynext, yrsp, err, enext, root), h) =
      D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)
   |  update_h (D.EventState (x, cx, y, xev, ev, ext, extev, _, ynext, yrsp, err, enext, root), h) =
      D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)
   |  update_h (D.ContState (x, cx, y, ext, extev, _, ynext, yrsp, err), h) =
      D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)

  fun state_sub (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root), i) =
      getindex(y, i)
   |  state_sub (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root), i) =
      getindex(y, i)
   |  state_sub (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err), i) =
      getindex(y, i)

  fun state_y (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = y
   |  state_y (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = y
   |  state_y (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = y

  fun state_indep (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = x
   |  state_indep (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = x
   |  state_indep (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = x

  fun state_h (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = h
   |  state_h (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = h
   |  state_h (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = h

  fun state_ext (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = ext
   |  state_ext (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = ext
   |  state_ext (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = ext

  fun state_extev (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = extev
   |  state_extev (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = extev
   |  state_extev (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = extev

  fun state_regime (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = r
   |  state_regime (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = Array.fromList []
   |  state_regime (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = Array.fromList[]

  fun state_event (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = ev
   |  state_event (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = ev
   |  state_event (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = Array.fromList []

  fun ext_sub (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root), i) = getindex(ext, i)
   |  ext_sub (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root), i) = getindex(ext, i)
   |  ext_sub (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err), i) = getindex(ext, i)

  fun event_sub (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root), i) =
      getindex(ev, i)
   |  event_sub (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root), i) =
      getindex(ev, i)
   |  event_sub (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err), i) =
      (putStrLn TextIO.stdOut "event_sub:"; raise Domain)

  fun state_root (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) = root
   |  state_root (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) = root
   |  state_root (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) = false

  fun copy_array a =
    let val len = Array.length a
        val b = if len>0 then Array.array (len, Array.sub(a,0)) else a
    in
        if len>0 then Array.copy {di=0, dst=b, src=a} else (); b
    end
                                                                     
  fun copy_state (D.RegimeState (x, cx, y, xev, ev, d, r, ext, extev, h, ynext, yrsp, err, enext, root)) =
    D.RegimeState(x, cx, copy_array y, xev, copy_array ev, copy_array d, copy_array r,
                  copy_array ext, copy_array extev, h, ynext, yrsp, err, enext, root)
   |  copy_state (D.EventState (x, cx, y, xev, ev, ext, extev, h, ynext, yrsp, err, enext, root)) =
      D.EventState (x, cx, copy_array y, xev, copy_array ev, copy_array ext, copy_array extev, h,
                    ynext, yrsp, err, enext, root) 
   |  copy_state (D.ContState (x, cx, y, ext, extev, h, ynext, yrsp, err)) =
      D.ContState (x, cx, copy_array y, copy_array ext, copy_array extev, h, ynext, yrsp, err)

        
  exception Index        
  exception InvalidPopulationSet of string

  val label = "{{group.name}}"
            
  val N = {{group.order}}     (* total population size *)

{% for pop in dict (group.populations) %}
    val {{pop.name}}_n0 = {{pop.value.start}}

{% endfor %}

{% if not (group.properties == []) %}
{% for p in dict (group.properties) %}
  val {{p.name}} = {{p.value.exprML}}

{% endfor %}
{% endif %}

  (* network propagation delays for each projection *)

  val D: real list = 
      [{% for pr in dict (group.projections) %}{{pr.value.delay.exprML}}{% if not loop.last %},{% endif %}{% endfor %}]

  val minDelay = foldl1 Real.min D

  val seed_init = RandomInit() (* seed for randomized initial values *)
  val zt_init   = ZigInit()
  fun random_normal () = RandomMTZig.randNormal(seed_init,zt_init)
  fun random_uniform () = RandomMTZig.randUniform(seed_init)
  fun random_uniform_vector () = RandomMTZig.randUniform(seed_init)
  fun random_int (imin,imax) = 
      let val range = imax - imin
      in
          imin + Real.round(Real.* (Real.fromInt(range), RandomMTZig.randUniform(seed_init)))
      end

{% for pop in dict (group.populations) %}

  val N_{{pop.name}} = {{ pop.value.size }}

  val {{pop.name}}_parameters = {{pop.value.prototype.name}}.paramfun()

  val {{pop.name}}_state_out = ref (TextIO.stdOut)

  val {{pop.name}}_ext_out = ref (TextIO.stdOut)

  val {{pop.name}}_event_out = ref (TextIO.stdOut)

(*
  val {{pop.name}}_field_vector = 
    Vector.tabulate (N_{{pop.name}}, fn (i) =>  {{pop.value.prototype.name}}.fieldfun({{pop.name}}_parameters))
*)

  val {{pop.name}}_initial_vector = 
      let
          val h0             = 1e~3
          val parameters     = {{pop.name}}_parameters
          val field_vector   = Vector.tabulate (N_{{pop.name}}, fn (i) => {{pop.value.prototype.name}}.fieldfun())
          val make_initial_vector' = make_initial_vector ({{pop.value.prototype.name}}.alloc,{{pop.value.prototype.name}}.bool_alloc,
                                                          {{pop.value.prototype.name}}.n,{{pop.value.prototype.name}}.nev,{{pop.value.prototype.name}}.ndsc,
                                                          {{pop.value.prototype.name}}.nregime)
      in
          List.tabulate
              (N_{{pop.name}},    
               fn(i) =>
                  let
                      val fields       = Vector.sub(field_vector,i)
                      val cond         = optApply {{pop.value.prototype.name}}.condfun (parameters,fields)
                      val initial      = {{pop.value.prototype.name}}.initfun(parameters,fields)
                      val evinitial    = {{pop.value.prototype.name}}.initcondfun
                      val dinitial     = optApply {{pop.value.prototype.name}}.dinitfun (parameters,fields)
                      val rinitial     = {{pop.value.prototype.name}}.initregfun
                      val extinitial   = {{pop.value.prototype.name}}.initextfun (parameters,fields)
                      val extevinitial = {{pop.value.prototype.name}}.initextevfun (parameters,fields)
                  in
                      (i, fields, make_initial_vector' (i,cond,initial,evinitial,dinitial,rinitial,extinitial,extevinitial,h0))
                  end)
      end

  val {{pop.name}}_ext_ports = [{% for portspec in dict (group.projectionPorts) %}{% if portspec.name == pop.name %}{% for port in portspec.value %}{{port}}{% if not loop.last %},{% endif %}{% endfor %}{% endif %}{% endfor %}]
                           
  fun {{pop.name}}_f (i,p,fld,rs,rszt) = 
      D.integral({{pop.value.prototype.name}}.odefun (p,fld,rs,rszt),
                 optApply {{pop.value.prototype.name}}.condfun (p,fld),
                 optApply {{pop.value.prototype.name}}.posfun (p,fld,rs,rszt),
                 optApply {{pop.value.prototype.name}}.negfun (p,fld,rs,rszt),
                 optApply {{pop.value.prototype.name}}.dposfun (p,fld,rs,rszt),
                 {{pop.value.prototype.name}}.regfun)

                
  fun {{pop.name}}_run f (rs,rszt) (statesample,extsample,evsample) (tend,Wmap,n0) ((i,fld,input),(nstates,spikes,statelog)) =
    let 
        val f' = f (i,{{pop.name}}_parameters,fld,rs,rszt)

(*
{% if pop.value.prototype.fieldExprML %}
        val fieldV = getindex ({{pop.name}}_field_vector,i)
{% endif %}
*)
        val statelog' = if (i<statesample) orelse (i<extsample) orelse (i<evsample) 
                        then ((i+{{pop.name}}_n0,copy_state input))::statelog
                        else statelog

        val update = Unsafe.Array.update
        val ext_i = state_ext input
        val extev_i = state_extev input

        val _ = 
            List.foldl
                (fn (port, index) => 
                    case IntMap.find (Wmap, i+n0) of
                        NONE => 
                        (update (ext_i, index, 0.0); 
                         update (extev_i, index, Real.posInf); 
                         index+1)
                      | SOME (spm) => 
                        case IntMap.find (spm, port) of
                            SOME (t,v) => 
                            (update (ext_i, index, v); 
                             update (extev_i, index, t); 
                             index+1)
                          | NONE => 
                            (update (ext_i, index, 0.0); 
                             update (extev_i, index, Real.posInf); 
                             index+1))
                0 {{pop.name}}_ext_ports
                
        fun recur (nstate, spikes, statelog) = 
            if state_indep nstate >= tend
            then 
                (nstate, spikes, statelog)
            else 
                (let 
                    val h' = Real.max(Real.min(tend-(state_indep nstate), state_h nstate), 1e~6)
                    val nstate'  = f' (update_h (nstate, h'))
                    val statelog'' = if state_root nstate' andalso ((i<statesample) orelse (i<extsample) orelse (i<evsample))
                                     then ((i+{{pop.name}}_n0,copy_state input))::statelog'
                                     else statelog'
                    val nstate'' = if state_root nstate' then f' nstate' else nstate'
                    val hasevent = Real.>= (event_sub(nstate'',0), 0.0)
                    val spikes'  = if hasevent then ((i+{{pop.name}}_n0,state_indep nstate',1.0))::spikes else spikes
                in
                    recur (nstate'', spikes', statelog'')
                end)

        val statelog' = if (i<statesample) orelse (i<extsample) orelse (i<evsample) 
                        then ((i+{{pop.name}}_n0,copy_state input))::statelog
                        else statelog

        val (nstate', spikes', statelog') = recur (input, spikes, statelog')
 in
     ((i,fld,nstate')::nstates, spikes', statelog')
 end

{% endfor %}

  val popmap = [
{% for s in dict (group.sets) %}
   ("{{s.name}}"{% for p in s.value.populations %}::"{{p.name}}"{% endfor %}::[]){% if not loop.last %},{% endif %}
{% endfor %} ]


{% if group.conntypes %}{% for conn in dict (group.conntypes) %}
{% if conn.value.sysFn %}
  val {{conn.name}}_initial = {{conn.value.initialExprML}}

  val {{conn.name}}_f = Model_{{conn.name}}.{{conn.value.sysFn}}

{% endif %}
{% endfor %}{% endif %}

    val initial = (
{% for pop in dict (group.populations) %}
        {{pop.name}}_initial_vector{% if not loop.last %},{% endif %}

{% endfor %}
    )

    val P = {{length(dict(group.populations))}}
                
    val Pn = [
        {% for pop in dict (group.populations) %}
        {{pop.name}}_n0{% if not loop.last %},{% endif %}

        {% endfor %}
    ]

    val Plabels = [
        {% for pop in dict (group.populations) %}
        "{{pop.name}}"{% if not loop.last %},{% endif %}

        {% endfor %}
    ]
         

    fun frun (rss, rszts) (statesample,extsample,evsample) (tend,I)
             (
{% for pop in dict (group.populations) %}
              {{pop.name}}_state_vector{% if not loop.last %},{% endif %}

{% endfor %} ) =
        let
            {% for pop in dict (group.populations) %}
            val rs   = List.nth(rss, {{loop.index0}})
            val rszt = List.nth(rszts, {{loop.index0}})

            val ({{pop.name}}_states,{{pop.name}}_spikes,{{pop.name}}_statelog) = 
                List.foldl ({{pop.name}}_run {{pop.name}}_f (rs,rszt) (statesample,extsample,evsample) (tend,I,{{pop.name}}_n0))
                           ([],[],[]) {{pop.name}}_state_vector

{% endfor %}
        in
            ((
{% for pop in dict (group.populations) %}
             {{pop.name}}_states{% if not loop.last %},{% endif %}

{% endfor %}
            ), 
             (
{% for pop in dict (group.populations) %}
             {{pop.name}}_spikes{% if not loop.last %},{% endif %}

{% endfor %}
             ),
             [
{% for pop in dict (group.populations) %}
             {{pop.name}}_statelog{% if not loop.last %},{% endif %}

{% endfor %}
            ])
        end
                         
    fun fspikeidxs spikesetName = 
        let 
            val spikesetPops = case List.find (fn(x) => spikesetName = (hd x)) popmap of
                                   SOME lst => tl lst
                                 | NONE => raise InvalidPopulationSet spikesetName
            val pops = [{% for pop in dict (group.populations) %}"{{pop.name}}"{% if not loop.last %},{% endif %}{% endfor %}]
            val popIdxs = ListPair.zip (pops, List.tabulate (List.length pops, fn (i) => i))
        in
            List.map (valOf o assoc popIdxs) spikesetPops
        end
                         

    fun fspikes spikelogIdxs (
{% for pop in dict (group.populations) %}
              {{pop.name}}_spike_i{% if not loop.last %},{% endif %}
{% endfor %} ) =

        let
            fun enqueueSpikes xs =
                List.foldl (fn(xs,ax) => List.foldl (fn((i,t,nv),ax) => SEQ.addEvent ((t,i),ax)) ax xs) SEQ.empty xs

            val all_spike_i = [{% for pop in dict (group.populations) %}{{pop.name}}_spike_i{% if not loop.last %},{% endif %}{% endfor %}]
            val labeled_spike_i = ListPair.zip (List.tabulate (List.length all_spike_i, fn (i) => i), all_spike_i)

            val (log_spike_i,ext_spike_i) = List.partition (fn(i,x) => member (i, spikelogIdxs)) labeled_spike_i

        in
            (enqueueSpikes all_spike_i, enqueueSpikes (map #2 log_spike_i))
        end

{% macro cartesian_product(sp, tp) %}
   {% for s,t in allCombs(sp,tp) %}
   {{ caller(s,t) }}{% if not loop.last %},{% endif %}
   {% endfor %}
{% endmacro %}

{% macro for_each(name, sp, tp, component, cstate) %}
             val Pr_{{name}} = BitSparseMatrix.fromGeneratorList [N,N]
                                  [
{% call cartesian_product (sp,tp) %}{offset=[{{t.start}},{{s.start}}],
                                     fshape=[{{t.size}},{{s.size}}],
                                     f=(fn (i) => #{{cstate}}({{component}}_f {{component}}_initial) )}{% endcall %}
                                  ]
{% endmacro %}


{% macro all_to_all(name, sp, tp)  %}
             val Pr_{{name}} = BitSparseMatrix.fromTensorList [N,N]
                                  [
{% call cartesian_product (sp,tp) %}{offset=[{{t.start}},{{s.start}}],
                                     tensor=(BitTensor.new ([{{t.size}},{{s.size}}],true)),
                                     sparse=false}{% endcall %}
                                  ]
{% endmacro %}

{% macro one_to_one(name, sp, tp) %}
             val Pr_{{name}} = BitSparseMatrix.fromTensorList [N,N]
                                  [
{% call cartesian_product (sp,tp) %}{offset=[{{t.start}},{{s.start}}],
                                     tensor=(fromDiag ({{t.size}},{{s.size}},BitArray.fromList [true],false)),
                                     sparse=true}{% endcall %}
                                  ]
{% endmacro %}


{% macro from_file(name, sp, tp, filename) %}
             val Pr_{{name}} = let val infile = TextIO.openIn "{{filename}}" 
                                   val S = TensorFile.realTensorRead (infile) 
                                   val _ = TextIO.closeIn infile
                               in 
                                   BitSparseMatrix.fromTensorSliceList [N,N]
                                   [
                                     {% with %}
                                     {% set soffset = 0 %}
                                     {% for s in sp %}
                                     {% set toffset = 0 %}
                                     {% for t in tp %}
                                     {offset=[{{t.start}},{{s.start}}],
                                      slice=(BitTensorSlice.slice ([([{{toffset}},{{soffset}}],[{{toffset}}+{{t.size}}-1,{{soffset}}+{{s.size}}-1])],S)),
                                      sparse=false}{% if not loop.last %},{% endif %}
                                     {% set toffset = toffset + t.size %}
                                     {% endfor %}{% if not loop.last %},{% endif %}
                                     {% set soffset = soffset + s.size %}
                                     {% endfor %}
                                     {% endwith %}
                                  ]
                                end
{% endmacro %}


{% macro preorder(sp, tp) %}
   {% for s in sp %}
   {% for t in tp %}
   {{ caller(s,t) }}{% if not loop.last %},{% endif %}
   {% endfor %}{% if not loop.last %},{% endif %}
   {% endfor %}
{% endmacro %}


{% macro postorder(sp, tp) %}
   {% for t in tp %}
   {% for s in sp %}
   {{ caller(s,t) }}{% if not loop.last %},{% endif %}
   {% endfor %}{% if not loop.last %},{% endif %}
   {% endfor %}
{% endmacro %}


{% macro random_fan_in(name, sp, tp, prob) %}
             val Pr_{{name}} = let
                                  val f = (fn (i) => if (Real.> ({{prob}}, random_uniform ())) then true else false) 
                               in
                                  BitSparseMatrix.fromGeneratorList [N,N]
                                  [
{% call postorder (sp,tp) %}          {offset=[{{t.start}},{{s.start}}],
                                       fshape=[{{t.size}},{{s.size}}],
                                       f=f}{% endcall %}
                                  ]
                               end
{% endmacro %}


{% macro random_fan_out(name, sp, tp, prob) %}
             val Pr_{{name}} = let
                                  val f = (fn (i) => if (Real.> ({{prob}}, random_uniform())) then true else false)
                               in
                                  BitSparseMatrix.fromGeneratorList [N,N]
                                  [
{% call preorder (sp,tp) %}         {offset=[{{t.start}},{{s.start}}],
                                     fshape=[{{t.size}},{{s.size}}],
                                     f=f}{% endcall %}
                                  ]
                               end
{% endmacro %}


{% macro random_fan_in_num(name, sp, tp, num) %}
             val Pr_{{name}} = BitSparseMatrix.fromVectors [N,N]
                                  [
{% call postorder (sp,tp) %}          (let
                                          val sample = Array.array (Int.min({{num | int}},{{s.size}}) * {{t.size}}, (0,0,false))
                                          val update = Unsafe.Array.update
                                          val _ = Loop.foldi (0,{{t.size}},
                                                              fn (i,k) => 
                                                                 Loop.foldi (0,{{num | int}},
                                                                             fn (j,k) => (update (sample,k,(i,random_int (0, {{s.size}}-1),true)); 
                                                                                          k+1),
                                                                             k),
                                                              0)
                                                                             
                                          val v = Array.vector sample
                                      in
                                          {offset=[{{t.start}},{{s.start}}],
                                           v=v, shape_v=[{{t.size}},{{s.size}}]}
                                      end){% endcall %}
                                  ]
{% endmacro %}


{% macro random_fan_out_num(name, sp, tp, num) %}
             val Pr_{{name}} = BitSparseMatrix.fromVectors [N,N]
                                  [
{% call preorder (sp,tp) %}          (let
                                          val sample = Array.array (Int.min({{num | int}},{{s.size}}) * {{t.size}}, (0,0,false))
                                          val update = Unsafe.Array.update
                                          val _ = Loop.foldi (0,{{t.size}},
                                                              fn (i,k) => 
                                                                 Loop.foldi (0,{{num | int}},
                                                                             fn (j,k) => (update (sample,k,(i,random_int (0, {{s.size}}-1),true)); 
                                                                                          k+1),
                                                                             k),
                                                              0)

                                          val v = Array.vector sample
                                      in
                                          {offset=[{{t.start}},{{s.start}}],
                                           v=v, shape_v=[{{t.size}},{{s.size}}]}
                                      end){% endcall %}
                                  ]
{% endmacro %}


{% macro range_map(name, sp, tp) %}
             val srangemap_{{name}} = 
                                    [
                                     {% with %}
                                     {% set soffset = 0 %}
                                     {% for s in sp %}
                                     {size={{s.size}}
                                      localStart={{soffset}},
                                      globalStart={{s.start}} }{% if not loop.last %},{% endif %}
                                     {% set soffset = soffset + s.size %}
                                     {% endfor %}
                                     {% endwith %}
                                    ]
             val trangemap_{{name}} = 
                                    [
                                     {% with %}
                                     {% set toffset = 0 %}
                                     {% for t in tp %}
                                     {size={{t.size}}
                                      localStart={{toffset}},
                                      globalStart={{t.start}} }{% if not loop.last %},{% endif %}
                                     {% set toffset = toffset + t.size %}
                                     {% endfor %}
                                     {% endwith %}
                                    ]
{% endmacro %}
           
           
    fun fprojection () =
        
        (let
             
{% for pr in dict (group.projections) %}
             val _ = putStrLn TextIO.stdOut "constructing {{pr.name}}"

{% if pr.value.connectivity.type.sysFn %}
{% call for_each(pr.name, 
                 pr.value.source.populations, 
                 pr.value.destination.populations, 
                 pr.value.connectivity.name,
                 pr.value.connectivity.port) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "OneToOne") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/OneToOne")) %}
{% call one_to_one(pr.name, 
                   pr.value.source.populations,
                   pr.value.destination.populations) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "AllToAll") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/AllToAll")) %}
{% call all_to_all(pr.name, 
                   pr.value.source.populations,
                   pr.value.destination.populations) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "FromFile") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/OneToOne")) %}
{% call from_file(pr.name, 
                  pr.value.source.populations,
                  pr.value.destination.populations,
                  pr.value.rule.properties.filename.exprML) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "RandomFanIn") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/RandomFanIn")) &&  pr.value.connectivity.type.probability %}
{% call random_fan_in(pr.name, 
                      pr.value.source.populations,
                      pr.value.destination.populations,
                      pr.value.connectivity.type.probability) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "RandomFanIn") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/RandomFanIn")) &&  pr.value.connectivity.type.number %}
{% call random_fan_in_num(pr.name, 
                          pr.value.source.populations,
                          pr.value.destination.populations,
                          pr.value.connectivity.type.number) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "RandomFanOut") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/RandomFanOut"))  &&  pr.value.connectivity.type.probability %}
{% call random_fan_out(pr.name, 
                pr.value.source.populations,
                pr.value.destination.populations,
                pr.value.connectivity.type.probability) %}
{% endcall %}
{% elseif ((pr.value.connectivity.type.stdlib == "RandomFanOut") || (pr.value.connectivity.type.stdlib == "http://nineml.net/9ML/1.0/connectionrules/RandomFanOut"))  &&  pr.value.connectivity.type.number %}
{% call random_fan_out(pr.name, 
                pr.value.source.populations,
                pr.value.destination.populations,
                pr.value.connectivity.type.number) %}
{% endcall %}
{% endif %}
{% endfor %}
                
       
             val S = ([ 
                       {% for pr in dict (group.projections) %}
                       {% if pr.value.type == "event" %}
                       Pr_{{pr.name}}{% if not loop.last %},{% endif %}
                       {% endif %}
                       {% endfor %}
                     ])

{% for pr in dict (group.projections) %}
{% if pr.value.type == "continuous" %}
{% call range_map(pr.name, 
                  pr.value.source.populations, 
                  pr.value.destination.populations) %}
{% endcall %}
{% endif %}
{% endfor %}

             val Elst =  
                      [ 
{% for pr in dict (group.projections) %}
                        {% if pr.value.type == "continuous" %}
                          ElecGraph.junctionMatrix ([N,N],ElecGraph.elecGraph ({{pr.name}}(srangemap_{{pr.name}},trangemap_{{pr.name}}))
                          Pr_{{pr.name}}){% if not loop.last %},{% endif %}
                        {% endif %}
{% endfor %}
                      ]

             val E = if List.null Elst then NONE else SOME Elst

             in
              S
             end)

end
        
