
structure Sim_{{group.name}} =
struct

fun putStrLn out str = 
    (TextIO.output (out, str);
     TextIO.output (out, "\n"))
    
fun putStr out str = 
    (TextIO.output (out, str))
    
    
fun showBoolean b = (if b then "1" else "0")
                    
                    
fun showReal n = 
    let open StringCvt
	open Real
    in
	(if n < 0.0 then "-" else "") ^ (fmt (FIX (SOME 12)) (abs n))
    end


fun timing (action) = 
    let
        val timer = Timer.startCPUTimer ()
        val result = action ()
        val times = Timer.checkCPUTimer timer
    in
        (result, Time.+ (#usr times, #sys times))
    end
                             

exception Index
exception Shape
fun dimVals [m,n] = (m,n) | dimVals _ = raise Shape

fun printProjectionSummary S k =
    List.app
        (fn (W) =>
            let
                val (m,n) = dimVals (SparseMatrix.shape W)
            in
                Loop.app (0, n,
                          fn (i) => 
                             let
                                 val sl = SparseMatrix.slice (W,k,i)
                                 val sln = SparseMatrix.sliceFoldi
                                               (fn (j,x,n) => n+1)
                                               0 sl
                                 val slsum = SparseMatrix.sliceFoldi
                                                 (fn (j,x,ax) => Real.+(ax,x))
                                                 0.0 sl
                             in
                                 putStrLn TextIO.stdOut
                                          ("column " ^ (Int.toString i) ^ 
                                           ": n = " ^ (Int.toString sln) ^
                                           ": mean = " ^ (Real.toString (Real./(slsum, (Real.fromInt sln)))))
                             end)
            end)
        S

{% if group.usempi %}
fun index_foreach (a, b, f) =
    if a <= b 
    then (f a; index_foreach (a+1, b, f))
    else ()

fun spikeGatherv (myrank, root, data) =
    (if (myrank = root)
     then (let 
               val (a,rlens) = MPI.Collective.recvGatherv (data, 0, MPI.Comm.World)
           in
               SOME a
           end)
     else (let 
               val status = MPI.Collective.sendGatherv (data, 0, MPI.Comm.World) 
           in
               NONE
           end);
     MPI.Barrier (MPI.Comm.World))
{% endif %}


fun start (tmax, N, S, D, DQ, initial_vector, frun, ftime, fspikes, finfo, out) =

let
    val sub = Unsafe.Real64Array.sub
    val isub = Unsafe.IntArray.sub
    val update = Unsafe.Real64Array.update

{% if group.usempi %}
    val myrank = {{group.name}}.myrank
    val mysize = {{group.name}}.mysize
{% endif %}
        
    fun netrun (DQ,state_vector) =
        let 
            val t = ftime state_vector
            val prio = {{group.name}}.TEventPriority.delayPriority t


{% if group.usempi %}
            val (Ilst,DQ') = 
                {{group.name}}.TEQ.nextEventsFold 
                              (fn (prio',_) => prio' <= prio,
                               fn (prio,(port,w),ax) => 
                                  let val t = {{group.name}}.TEventPriority.priorityDelay (prio, {{group.name}}.h)
                                  in
                                      (port,(t,w)) :: ax
                                  end,[],DQ)

            Ivec format: port numElem gid0 weight0 ... gidN weightN
            val I = index_foreach
                        (0, mysize, 
                         fn (i) => 
                            if i=myrank 
                            then spikeGatherv(myrank, i, Ivec)
                            else (spikeGatherv(myrank, i, Ivec)))


{% else %}
            val (I,DQ') = 
                {{group.name}}.TEQ.nextEventsFold 
                              (fn (prio',_) => prio' <= prio,
                               fn (prio,(port,w),ax) => 
                                  let val t = {{group.name}}.TEventPriority.priorityDelay (prio, {{group.name}}.h)
                                  in
                                      IntMap.insert (ax,port,(t,w))
                                  end,
                               IntMap.empty,
                               DQ)
{% endif %}

            val (state_vector_i, spikes_i) = frun I state_vector

            val t_i = ftime state_vector_i

            val (spike_i, log_spike_i) = fspikes spikes_i
                
            val _   = finfo (state_vector_i, out)
                              
{% if group.usempi %}
            val W''  = 
                if (List.null spike_i)
                then NONE
                else SOME 
                         (List.map
                              (fn (W) =>
                                  let
                                      val Ts = Array.tabulate(mysize, fn(i) => DynArray.array (N, 0.0))
                                  in
                                      (List.app
                                           (fn (i,nv) => 
                                               let
                                                   val sl = SparseMatrix.slice (W,1,i)
                                               in
                                                   SparseMatrix.sliceAppi 
                                                       (fn (j,x) => 
                                                           let
                                                               val T = Unsafe.Array.sub(Ts,Int.mod(j, mysize))
                                                           in
                                                               update (T, j, Real.+ (Real.* (nv,x), sub(T,j)))
                                                           end)
                                                       sl
                                               end)
                                           spike_i; 
                                       Ts)
                                  end)
                              S)
{% else %}
            val W''  = 
                if (List.null spike_i)
                then NONE
                else SOME 
                         (List.map
                              (fn (W) =>
                                  let
                                      val T = Real64Array.array (N, 0.0)
                                  in
                                      (List.app
                                           (fn (i,nv) => 
                                               let
                                                   val sl = SparseMatrix.slice (W,1,i)
                                               in
                                                   SparseMatrix.sliceAppi 
                                                       (fn (j,x) => update (T,j,Real.+ (Real.* (nv,x), sub(T,j))))
                                                       sl
                                               end)
                                           spike_i;
                                       Real64Array.foldli 
                                           (fn (i,v,m) => if not (Real.==(v, 0.0)) then IntMap.insert(m,i,v) else m)
                                           IntMap.empty T)
                                  end)
                              S)
{% endif %}
                              
            val _ = 
                if not (List.null log_spike_i)
                then (putStr out ((showReal t_i) ^ " ");
                      TensorFile.intListLineWrite out (List.map (fn (i,n) => (i+1)) log_spike_i))
                else (putStrLn out ("# " ^ (showReal t_i)))
                         
                         
            val DQ'' = 
                case W'' of
                    SOME W => 
                    let
{% if group.usempi %}
                        val DW: (real list * (DynArray.array array) list) = (D,W)
{% else %}
                        val DW: (real list * (real IntMap.map) list) = (D,W)
{% endif %}
                    in
                        (#2(ListPair.foldl
                                (fn(del: real,w: real IntMap.map,(port,dq)) => 
                                    let val tev = Real.+ (t_i,del)
                                    in
                                        (port+1, {{group.name}}.TEQ.addEvent ((tev, (port,w)), dq))
                                    end)
                                (0, DQ') 
                                DW))
                    end
                  | NONE => DQ'
        in
            if t_i  > tmax
            then (putStrLn out "# All done!"; state_vector_i)
            else netrun (DQ'',state_vector_i)
        end
in
    netrun (DQ,initial_vector)
end

fun main (name,args) =
    let
        open {{group.name}}
        fun finfo (_,out) = ()
    in
        (let
            val     _ = putStrLn TextIO.stdOut ("starting fprojection...")
            val (S,t) = timing fprojection
            val     _ = putStrLn TextIO.stdOut ("fprojection took " ^ (Time.toString t) ^ " s")
            val out   = TextIO.openOut (label ^ ".dat")

{% for pop in dict (group.populations) %}
{% if group.statesample > 0 %}

            val _ = ({{pop.name}}_state_out := TextIO.openOut ("{{pop.name}}_state.dat"))

{% endif %}
{% if group.extsample > 0 %}

            val _ = ({{pop.name}}_ext_out := TextIO.openOut ("{{pop.name}}_ext.dat"))

{% endif %}
{% if group.evsample > 0 %}

            val _ = ({{pop.name}}_event_out := TextIO.openOut ("{{pop.name}}_event.dat"))

{% endif %}
{% endfor %}

        in
            List.app (fn (s) => putStrLn out ("# " ^ s))
                     ([
                         label

                     ]);
            let
                val _     = putStrLn TextIO.stdOut ("starting simulation...")
                val (_,t) = timing (fn () => start ({{duration}}, N, S, D, DQ, initial, frun, ftime, fspikes, finfo, out))
            in
                putStrLn TextIO.stdOut ("simulation took " ^ (Time.toString t) ^ " s")
            end;
            
            TextIO.flushOut (out);
            TextIO.closeOut (out);

{% for pop in dict (group.populations) %}
{% if group.statesample > 0 %}

            TextIO.flushOut (!{{pop.name}}_state_out); 
            TextIO.closeOut (!{{pop.name}}_state_out);

{% endif %}
{% if group.extsample > 0 %}

            TextIO.flushOut (!{{pop.name}}_ext_out); 
            TextIO.closeOut (!{{pop.name}}_ext_out);

{% endif %}
{% if group.evsample > 0 %}

            TextIO.flushOut (!{{pop.name}}_event_out); 
            TextIO.closeOut (!{{pop.name}}_event_out);

{% endif %}
{% endfor %}

        ()

        end)
    end
    

end

val _ = let val name = CommandLine.name()
	    val args = CommandLine.arguments()
	    val env  = Posix.ProcEnv.environ()
	in
	    Sim_{{group.name}}.main (name, args);
{% if group.usempi %}
           MPI.Finalize ()
{% else %}
           ()
{% endif %}
	end
