
structure Sim_{{group.name}} =
struct

fun putStrLn out str = 
    (TextIO.output (out, str);
     TextIO.output (out, "\n"))
    
fun putStr out str = 
    (TextIO.output (out, str))
    
    
fun showBoolean b = (if b then "1" else "0")
                    
                    
fun showReal n = 
    let open StringCvt
	open Real
    in
	(if n < 0.0 then "-" else "") ^ (fmt (FIX (SOME 12)) (abs n))
    end


fun timing (action) = 
    let
        val timer = Timer.startCPUTimer ()
        val result = action ()
        val times = Timer.checkCPUTimer timer
    in
        (result, Time.+ (#usr times, #sys times))
    end
                             

exception Index

fun start (tmax, N, S, D, DQ, Pn, initial_vector, frun, ftime, fspikes, finfo, out) =

let
    val sub = Real64Array.sub
    val isub = IntArray.sub
    val update = Real64Array.update

        
    fun netrun (DQ,state_vector) =
        let 
            val t = ftime state_vector
            val prio = {{group.name}}.TEventPriority.delayPriority t

            val (I,DQ') = {{group.name}}.TEQ.nextEventsFold 
                                        (fn (prio',_) => prio' <= prio,
                                         fn (_,(port,w),ax) => IntMap.insert (ax,port,w),
                                         IntMap.empty,
                                         DQ)
            
            val state_vector_i = frun I state_vector

            val t_i = ftime state_vector_i

            val (spike_i, log_spike_i) = fspikes state_vector_i
                
            val _   = finfo (state_vector_i, out)
                              
            val W''  = 
                if (List.null spike_i)
                then NONE
                else SOME 
                         (List.map
                              (fn (W) =>
                                  let
                                      val T = Real64Array.array (N, 0.0)
                                  in
                                      (List.app
                                           (fn (i,nv) => 
                                               let
                                                   val sl = SparseMatrix.slice (W,1,i)
                                               in
                                                   SparseMatrix.sliceAppi 
                                                       (fn (j,x) => update (T,j,Real.+ (Real.* (nv,x), sub(T,j))))
                                                       sl
                                               end)
                                           spike_i;
                                       SparseMatrix.fromTensor [N,1] (RTensor.fromArray ([N,1], T), NONE))
                                  end)
                              S)
                              
            val _ = 
                if not (List.null log_spike_i)
                then (putStr out ((showReal t_i) ^ " ");
                      TensorFile.intListLineWrite out (List.map (fn (i,n) => (i+1)) log_spike_i))
                else (putStrLn out ("# " ^ (showReal t_i)))
                         
                         
            val DQ'' = 
                case W'' of
                    SOME W => 
                    let
                        val DW: (real list * SparseMatrix.matrix list) = (D,W)
                    in
                        (#2(ListPair.foldl
                                (fn(del: real,w: SparseMatrix.matrix,(port,dq)) => 
                                    (port+1, {{group.name}}.TEQ.addEvent ((Real.+ (t_i,del), (port,w)), dq)))
                                (0, DQ') 
                                DW))
                    end
                  | NONE => DQ'
        in
            if t_i  > tmax
            then (putStrLn out "# All done!"; state_vector_i)
            else netrun (DQ'',state_vector_i)
        end
in
    netrun (DQ,initial_vector)
end

fun main (name,args) =
    let
        open {{group.name}}
        fun finfo (_,out) = ()
    in
        (let
            val     _ = putStrLn TextIO.stdOut ("starting fprojection...")
            val (S,t) = timing fprojection
            val     _ = putStrLn TextIO.stdOut ("fprojection took " ^ (Time.toString t) ^ " s")
            val out   = TextIO.openOut (label ^ ".dat")
        in
            List.app (fn (s) => putStrLn out ("# " ^ s))
                     ([
                         label

                     ]);
            let
                val _     = putStrLn TextIO.stdOut ("starting simulation...")
                val (_,t) = timing (fn () => start (1200.0, N, S, D, DQ, Pn, initial, frun, ftime, fspikes, finfo, out))
            in
                putStrLn TextIO.stdOut ("simulation took " ^ (Time.toString t) ^ " s")
            end;
            
            TextIO.flushOut (out);
            TextIO.closeOut (out)
        end)
    end
    

end

val _ = let val name = CommandLine.name()
	    val args = CommandLine.arguments()
	    val env  = Posix.ProcEnv.environ()
	in
	    Sim_{{group.name}}.main (name, args)
	end
