
structure Sim_{{group.name}} =
struct


fun putStrLn out str = 
    (TextIO.output (out, str);
     TextIO.output (out, "\n"))
    
fun putStr out str = 
    (TextIO.output (out, str))
    
    
fun showBoolean b = (if b then "1" else "0")
                    
                    
fun showReal n = 
    let open StringCvt
	open Real
    in
	(if n < 0.0 then "-" else "") ^ (fmt (FIX (SOME 12)) (abs n))
    end


fun timing (action) = 
    let
        val timer = Timer.startCPUTimer ()
        val result = action ()
        val times = Timer.checkCPUTimer timer
    in
        (result, Time.+ (#usr times, #sys times))
    end

val h = ref 0.1

structure TEventPriority = 
struct
       type priority     = int
       (* Given a delay (positive real number), compute the priority given a time step *)
       fun delayPriority (delay) = Real.round (Real./ (delay, (!h)))
       (*  Given a priority and a time step, computes the corresponding delay *)
       fun priorityDelay (priority,h) = Real.* (Real.fromInt priority, (!h))
       
       fun compare (x,y) = Int.compare (x,y)
       type item         = real * (int * (real IntMap.map))
       fun priority (x : item) = delayPriority (#1(x))
  end

structure TEQ = FixTEventQueue (structure P = TEventPriority
                                type value = (int * (real IntMap.map))
                                fun value (x : P.item) = (#2(x)))
val DQ = TEQ.empty
                             

exception Index
exception Shape
fun dimVals [m,n] = (m,n) | dimVals _ = raise Shape

fun writeProjection S prefix =
  ListPair.app
      (fn (W,p) =>
          let
              val out = TextIO.openAppend (prefix ^ "." ^ (Int.toString p) ^ ".prj.dat")
              val (m,n) = dimVals (BitSparseMatrix.shape W)
          in
              Loop.app (0, n,
                        fn (i) => 
                           let
                               val sl = BitSparseMatrix.slice (W,1,i)
                               val lst = BitSparseMatrix.sliceFoldi
                                             (fn (j,x,lst) => j::lst)
                                             [] sl
                           in
                               List.app
                                   (fn (j) => putStrLn out ( (Int.toString i) ^ " " ^ (Int.toString j)))
                                   lst
                           end);
              TextIO.flushOut out; 
              TextIO.closeOut out
          end)
      (S, List.tabulate (List.length S, fn(i) => i))

                     
fun writeLog Plabels (spike_filepath,state_prefix,ext_prefix,event_prefix) (statelog,spikelog) =
  let
      open {{group.name}}
      val _ = case state_prefix of
                  SOME prefix =>
                  ListPair.app
                      (fn (label,lst) =>
                          let val state_out = TextIO.openAppend (prefix ^ "." ^ label ^ ".dat")
                          in
                              List.app
                                  (fn (i,nstate) =>
                                      putStrLn state_out        
                                               (Int.toString (i) ^ ", " ^ (showReal (state_indep nstate)) ^ ", " ^
                                                (showRealArray (state_y nstate))))
                                  (List.rev lst);
                              TextIO.flushOut state_out; 
                              TextIO.closeOut state_out
                          end)
                       (Plabels,statelog)
                | NONE => ()
                  
      val _ = case ext_prefix of
                  SOME prefix =>
                  ListPair.app
                      (fn (label,lst) =>
                          let val ext_out = TextIO.openAppend (prefix ^ "." ^ label ^ ".dat")
                          in
                              List.app
                                  (fn (i,nstate) =>
                                      putStrLn ext_out
                                               (Int.toString (i) ^ ", " ^ (showReal (state_indep nstate)) ^ ", " ^
                                                (showRealArray (state_ext nstate)) ^ ", " ^
                                                (showRealArray (state_extev nstate))))
                                  (List.rev lst);
                              TextIO.flushOut ext_out; 
                              TextIO.closeOut ext_out
                          end)
                      (Plabels,statelog)
                | NONE => ()
                  
      val _ = case event_prefix of
                  SOME prefix =>
                  ListPair.app
                      (fn (label,lst) =>
                          let val event_out = TextIO.openAppend (prefix ^ "." ^ label ^ ".dat")
                          in
                              List.app
                                  (fn (i,nstate) =>
                                      putStrLn event_out
                                               (Int.toString (i) ^ ", " ^ (showReal (state_indep nstate)) ^ ", " ^
                                                (showRealArray (state_event nstate))))
                                  (List.rev lst);
                              TextIO.flushOut event_out; 
                              TextIO.closeOut event_out
                          end)
                      (Plabels,statelog)
                | NONE => ()
                  
      val _ = let val spike_out = TextIO.openAppend spike_filepath
              in
                  List.app
                      (fn (t_i,pop) =>
                          (putStr spike_out ((showReal t_i) ^ " ");
                           List.app
                               (fn (lst) =>
                                   List.app (fn x => (TextIO.output(spike_out, " " ^ (Int.toString x))))
                                            (List.map (fn (i,n) => (i+1)) lst))
                               pop;
                           putStrLn spike_out ""))
                      (List.rev spikelog);
                  TextIO.flushOut spike_out; 
                  TextIO.closeOut spike_out
              end

  in
      ()
  end


fun start (N, S, D, DQ, Pn, Plabels, initial_vector, frun, ftime, fspikes, finfo, tstop, logperiod,
           (spikeout_filepath,stateout_prefix,extout_prefix,eventout_prefix),
           (statesample,extsample,evsample)) =

let
    val sub = Unsafe.Real64Array.sub
    val isub = Unsafe.IntArray.sub
    val update = Unsafe.Real64Array.update

    val frun' = frun (statesample,extsample,evsample)
          
    val writeLog' = writeLog Plabels (spikeout_filepath,stateout_prefix,extout_prefix,eventout_prefix)
                             
    fun netrun (DQ,state_vector,spikelog,statelog,tlog) =
        let 
            val t = ftime state_vector
            val prio = TEventPriority.delayPriority (t)

            val (I,DQ') = TEQ.nextEventsFold 
                              (fn (prio',_) => prio' <= prio,
                               fn (prio,(port,w),ax) => 
                                  let val t = TEventPriority.priorityDelay (prio, h)
                                  in
                                      IntMap.insert (ax,port,(t,w))
                                  end,
                               IntMap.empty,
                               DQ)

            val (state_vector_i, spikes_i, statelog_i) = frun' (!h) I state_vector

            val t_i = ftime state_vector_i

            val (spike_i, spikelog_i) = fspikes spikes_i
                
            val _   = finfo state_vector_i
                              
            val W''  = 
                if (List.null spike_i)
                then NONE
                else SOME 
                         (List.map
                              (fn (W) =>
                                  let
                                      val T = Real64Array.array (N, 0.0)
                                  in
                                      (List.app
                                           (fn (lst) =>
                                               List.app
                                                   (fn (i,nv) => 
                                                       let
                                                           val sl = BitSparseMatrix.slice (W,1,i)
                                                       in
                                                           BitSparseMatrix.sliceAppi 
                                                               (fn (j,x) => update (T,j,Real.+ (nv, sub(T,j))))
                                                               sl
                                                       end)
                                                   lst)
                                           spike_i;
                                       Real64Array.foldli 
                                           (fn (i,v,m) => if not (Real.==(v, 0.0)) then IntMap.insert(m,i,v) else m)
                                           IntMap.empty T)
                                  end)
                              S)
                              
            val DQ'' = 
                case W'' of
                    SOME W => 
                    let
                        val DW: (real list * (real IntMap.map) list) = (D,W)
                    in
                        (#2(ListPair.foldl
                                (fn(del: real,w: real IntMap.map,(port,dq)) => 
                                    let val tev = Real.+ (t_i,del)
                                    in
                                        (port+1, TEQ.addEvent ((tev, (port,w)), dq))
                                    end)
                                (0, DQ') 
                                DW))
                    end
                  | NONE => DQ'

            val _ = if t_i >= tlog orelse t_i >= tstop
                    then (writeLog' (if List.null statelog then statelog_i else ListPair.map (op @) (statelog_i, statelog),
                                     (t_i,spikelog_i)::spikelog))
                    else ()
                                
            val (tlog',statelog',spikelog') =
                if t_i >= tlog orelse t_i >= tstop
                then (t + logperiod, [], [])
                else (tlog,
                      if List.null statelog then statelog_i else ListPair.map (op @) (statelog_i, statelog),
                      (t_i,spikelog_i)::spikelog)
        in
            
            if t_i > tstop
            then state_vector_i
            else netrun (DQ'', state_vector_i, spikelog', statelog', tlog')
        end
in
    netrun (DQ,initial_vector,[(0.0,[])],[],0.0)
end

exception Exit of OS.Process.status 

fun exitError (prog, msg) = 
    let 
	val _ = TextIO.output(TextIO.stdErr, prog ^ ": " ^ msg ^ "\n")
    in 
	raise Exit OS.Process.failure 
    end
	    
fun exitHelp prog = 
    let 
	val _ = TextIO.output(TextIO.stdOut, (Options.usage prog) ^ "\n")
    in 
	raise Exit OS.Process.success 
    end

fun main (name,args) =
  let
      open {{group.name}}

        fun finfo (_) = ()

        val optStatus = ref NONE
        val (opts, _) = (Options.getopt optStatus) args
                                                   
        val _ = (case !optStatus of 
	             SOME msg => exitError (CommandLine.name(), msg)
	           | NONE => ())
		    
        val {is_help, is_time, is_timestep, is_tol, is_logperiod, 
             is_statesample, is_extsample, is_evsample,
             is_spikerecord, is_prjrecord, 
             is_spikeout, is_stateprefix,
             is_extprefix, is_eventprefix,
             is_prjprefix} = Options.getstate (opts)
						                       
        val _ = if is_help then exitHelp (CommandLine.name()) else ()
        val _ = case (is_statesample, is_extsample, is_evsample, is_spikerecord) of
                    (NONE, NONE, NONE, NONE) => 
                    (putStrLn TextIO.stdErr ("No options for state sampling or event recording have been specified;");
                     putStrLn TextIO.stdErr ("State traces and spike event times will not be recorded."))
                    | (_, _, _, _) => ()
                                                                       
        val _     = case is_timestep of SOME dt => (h := dt) | NONE => ()
        val tstop = case is_time of SOME t => t | NONE => 150.0
        val logperiod = case is_logperiod of SOME t => t | NONE => 100.0
                                                              
        val statesample = case is_statesample of SOME n => n | NONE => 0
        val extsample = case is_extsample of SOME n => n | NONE => 0
        val evsample = case is_evsample of SOME n => n | NONE => 0
        val spikelog = case is_spikerecord of SOME n => fspikeidxs n | NONE => []

        val spikeout_filepath = case is_spikeout of SOME s => s | NONE => label ^ ".dat"
        val stateout_prefix = if statesample>0
                              then (case is_stateprefix of SOME s => SOME s | NONE => SOME (label ^ "_state"))
                              else NONE
        val extout_prefix   = if extsample>0
                              then (case is_extprefix of SOME s => SOME s | NONE => SOME (label ^ "_ext"))
                              else NONE
        val eventout_prefix = if evsample>0
                              then (case is_eventprefix of SOME s => SOME s | NONE => SOME (label ^ "_event"))
                              else NONE
        val prjout_prefix   = case is_prjprefix of SOME s => s | NONE => label

    in
        (let
            val     _ = putStrLn TextIO.stdOut ("constructing projections...")
            val (S,t) = timing fprojection
            val     _ = putStrLn TextIO.stdOut ("projections took " ^ (Time.toString t) ^ " s")

            val _ = if is_prjrecord
                    then writeProjection S prjout_prefix
                    else ()
                                 
            val _ = (case is_spikerecord of
                         SOME s =>
                         let val spike_out = TextIO.openOut spikeout_filepath
                         in
                             List.app (fn (s) => putStrLn spike_out ("# " ^ s))
                                      ([
                                          label
                                      ]);
                             TextIO.closeOut spike_out
                         end
                       | NONE => ();
                     case stateout_prefix of
                         SOME prefix =>
                         List.app
                             (fn(label) =>
                                 let val state_out = TextIO.openOut (prefix ^ "." ^ label ^ ".dat")
                                 in
                                     TextIO.closeOut state_out
                                 end)
                             Plabels
                       | NONE => ();
                     case extout_prefix of
                         SOME prefix =>
                         List.app
                             (fn(label) =>
                                 let val ext_out = TextIO.openOut (prefix ^ "." ^ label ^ ".dat")
                                 in
                                     TextIO.closeOut ext_out
                                 end)
                             Plabels
                       | NONE => ();
                     case eventout_prefix of
                         SOME prefix =>
                         List.app
                             (fn(label) =>
                                 let val event_out = TextIO.openOut (prefix ^ "." ^ label ^ ".dat")
                                 in
                                     TextIO.closeOut event_out
                                 end)
                             Plabels
                      | NONE => ()
                    )

            val _     = putStrLn TextIO.stdOut ("starting simulation...")
            val (_,t) = timing (fn () => start (N, S, D, DQ, Pn, Plabels, initial, frun, 
                                                ftime, fspikes spikelog, finfo, tstop, logperiod,
                                                (spikeout_filepath,stateout_prefix,
                                                 extout_prefix,eventout_prefix),
                                                (statesample,extsample,evsample)))
        in
            putStrLn TextIO.stdOut ("simulation took " ^ (Time.toString t) ^ " s")
        end)
    end
    

end

val _ = let val name = CommandLine.name()
	    val args = CommandLine.arguments()
	    val env  = Posix.ProcEnv.environ()
	in
	    Sim_{{group.name}}.main (name, args)
	end
